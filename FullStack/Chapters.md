1. gRPC Protobuf
	1. Os/Hardware/Language에 관계 없이 동작할 수 있도록 해주는 IDL컴파일러이다
	2. gRPC메세지를 바이너리 메세지 포맷으로 직렬화를 수행한다

2. proto화요리
	syntax : gRPC문법 버전
	 Service: RPC정의, 서비스에 속하는 메서드들과 메서드의 인자, 반환값등을 명시한다
	 MEssage: gRPC에서 소통시 사용되는 데이터 구조 정의: 
3. 독립적 동작
	1. Serialized Format: Protobuf를 운체, 언어, 하드웨어에 상관없이 모두 이해할 수 있는 0과 1의 바이너리 메세지 포맷으로 직렬화를 수행하기 때문입니다

4. Unary - Client에서 여러 요청을 리스트형식으로 한꺼번에 전달하고 서버에서 리스트형식의 요청을 한꺼번에 응답하는 방식 - 주문 시스템
5. Bidirecitonal -Streaming: 클라이언트와 서버가 계속해서 정보를 스트리밍하면서 주고 받는 방식이다. 메세지를 실시간으로 주고 받는 실시간 채팅 어플리케이션이있다
6. CLient Streaming - 클라이언트에서 여러개의 요청을 스트리밍 형태로 넘겨주면 서버에서 한꺼번에 응답하는 형태이다. 대용량 파일 업로드
7. 서버 스트리밍 - 클라이언트에서 단일 요청을 전송하면 여러개의 응답을 스트리밍해서 넘겨준다
 - 유튜브 스트리밍

gRPC는 Protobuf를 사용하여 메세지를 바이너리 메세지 형태로 전송하기 때문에 메세지의 크기가 작아져 더 적은 네트워크 대역폭으로 통신하여 오버헤드를 줄인다
자동 코드 생성을 할 수 있기 때문에 클라이언트와 서버의 코드의 중복을 줄이고 개발 시간 단축
Strict Speicification: 일관성 유지, 개발 시간 단축?

단점: 아직 브라우저에서 직접적으로 gRPC제공하지 않는다, 사람이 읽을 수 없는 형식이다

HOL(Head-of -Line): HTTP1.1에서는 클라이언트에서 전송한 요청을 순차적으로 처리하기 때문에 앞선 요청에 문제가 생기면 후속 요청들은 클라이언트에 전달되지 못하고 지연되게 됩니다
Fat Message HeadeR: HTTP1.1에서는 메세지의 헤더에 쿠키 정보들을 포함한 다양한 메타데이터가 들어간다. 하지만 각 메세지는 서로에게 독립적이기 때문에 중복된 헤더들도 계속해서 전송하게 된다. 이는 헤더가 크기가 커지게 되면 네트워크의 트래픽을 증가시켜 요청과 응답이 느려지게 된다
Limited Priority: 우선순위 개념이 존재하지 않아 사용자가 필요로 하는 데이터를 받을 때 다른 요청들을 기다려야하므로 지연이 발생한다

